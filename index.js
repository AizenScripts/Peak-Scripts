/**
 * role-writer-bot
 *
 * - /addrole @user rol [file:<luaFile>]  -> add id to roles.json and to target lua file's bypass = { ... } block
 * - /removerole @user rol [file:<luaFile>] -> remove id from roles.json and lua file
 * - /listrole rol [file:<luaFile>] -> list ids from roles.json
 * - /maprole rol file:<luaFile> -> map a role name to a specific lua file (without extension)
 *
 * Behavior:
 * - If mapping exists for a role, bot writes to lua/<mapping>.lua
 * - If explicit file param passed to /addrole or /removerole, that file is used
 * - Otherwise default: lua/<safe_role_name>.lua
 * - bypass block format: no trailing comma on the last element
 * - Atomic writes (tmp -> rename)
 *
 * Security:
 * - Commands limited to Administrators by default
 * - Lua filenames sanitized and restricted to lua/ directory
 */

require('dotenv').config();
const fs = require('fs');
const path = require('path');
const { Client, GatewayIntentBits, REST, Routes, SlashCommandBuilder, PermissionsBitField } = require('discord.js');

const TOKEN = process.env.DISCORD_TOKEN;
const GUILD_ID = process.env.TEST_GUILD_ID || null;
if (!TOKEN) {
  console.error('DISCORD_TOKEN .env içinde bulunamadı. Çıkılıyor.');
  process.exit(1);
}

const DATA_FILE = path.join(__dirname, 'roles.json');
const MAPPINGS_FILE = path.join(__dirname, 'mappings.json');
const LUA_DIR = path.join(__dirname, 'lua');
const LOG_FILE = path.join(__dirname, 'actions.log');

const client = new Client({ intents: [GatewayIntentBits.Guilds] });

// --- Helpers ---
function ensureDir(dir) {
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
}

// safe role name for default filenames
function safeRoleName(roleName) {
  return roleName.replace(/[^a-zA-Z0-9_]/g, '_').toLowerCase();
}

// safe lua filename (no extension) - allow letters, numbers, underscore, dash
function safeLuaFilename(name) {
  return String(name).replace(/[^a-zA-Z0-9_-]/g, '_');
}

function loadJSON(filePath) {
  try {
    if (!fs.existsSync(filePath)) return {};
    const raw = fs.readFileSync(filePath, 'utf8') || '{}';
    return JSON.parse(raw);
  } catch (err) {
    console.warn(`${path.basename(filePath)} okunurken hata:`, err);
    return {};
  }
}
function saveJSONAtomic(filePath, obj) {
  const tmp = filePath + '.tmp';
  fs.writeFileSync(tmp, JSON.stringify(obj, null, 2), 'utf8');
  fs.renameSync(tmp, filePath);
}
function appendLog(line) {
  const ts = new Date().toISOString();
  try {
    fs.appendFileSync(LOG_FILE, `[${ts}] ${line}\n`, 'utf8');
  } catch (e) {
    console.warn('Log yazılamadı:', e);
  }
}

// Roles & mappings
function loadRoles() { return loadJSON(DATA_FILE); }
function saveRoles(obj) { saveJSONAtomic(DATA_FILE, obj); }
function loadMappings() { return loadJSON(MAPPINGS_FILE); }
function saveMappings(obj) { saveJSONAtomic(MAPPINGS_FILE, obj); }

// Resolve lua path for a given role (explicitFile without extension optional)
function getLuaPathForRole(roleName, explicitFile = null) {
  ensureDir(LUA_DIR);
  if (explicitFile) {
    const safe = safeLuaFilename(explicitFile);
    return path.join(LUA_DIR, `${safe}.lua`);
  }
  const mappings = loadMappings();
  if (mappings[roleName]) {
    const safe = safeLuaFilename(mappings[roleName]);
    return path.join(LUA_DIR, `${safe}.lua`);
  }
  const safeRole = safeRoleName(roleName);
  return path.join(LUA_DIR, `${safeRole}.lua`);
}

// Read file helper
function readFileIfExists(filePath) {
  if (!fs.existsSync(filePath)) return '';
  return fs.readFileSync(filePath, 'utf8') || '';
}

// Parse existing IDs from bypass block in content
function parseBypassIdsFromContent(content) {
  const bypassRegex = /bypass\s*=\s*\{([\s\S]*?)\}/m;
  if (!bypassRegex.test(content)) return [];
  const m = content.match(bypassRegex);
  const inside = m[1] || '';
  const matches = [...inside.matchAll(/"([^"]+)"/g)];
  return matches.map(x => x[1]);
}

// Build bypass block with no trailing comma on last element
function buildBypassBlock(roleName, ids) {
  const unique = Array.from(new Set(ids)).sort();
  const lines = [];
  lines.push('-- Auto-generated bypass block (managed by role-writer-bot)');
  lines.push(`-- Role: ${roleName}`);

  if (unique.length === 0) {
    lines.push('bypass = {}');
    return lines.join('\n');
  }

  lines.push('bypass = {');
  for (let i = 0; i < unique.length; i++) {
    const id = unique[i];
    const comma = (i === unique.length - 1) ? '' : ',';
    lines.push(`  "${id}"${comma}`);
  }
  lines.push('}');
  return lines.join('\n');
}

// Add id to a specific lua file's bypass block (rebuilds block so last item has no comma)
function addIdToLuaFile(filePath, roleName, id) {
  ensureDir(LUA_DIR);
  let content = '';
  if (fs.existsSync(filePath)) content = fs.readFileSync(filePath, 'utf8') || '';

  const existingIds = parseBypassIdsFromContent(content);
  if (existingIds.includes(id)) {
    // already present
    return filePath;
  }

  const newIds = existingIds.concat([id]);
  const newBlock = buildBypassBlock(roleName, newIds);

  const bypassRegex = /bypass\s*=\s*\{([\s\S]*?)\}/m;
  let newContent;
  if (bypassRegex.test(content)) {
    newContent = content.replace(bypassRegex, newBlock);
  } else {
    if (content.length > 0 && !content.endsWith('\n')) content += '\n';
    newContent = content + '\n' + newBlock + '\n';
  }

  const tmp = filePath + '.tmp';
  fs.writeFileSync(tmp, newContent, 'utf8');
  fs.renameSync(tmp, filePath);
  return filePath;
}

// Remove id from a specific lua file's bypass block (rebuilds block)
function removeIdFromLuaFile(filePath, roleName, idToRemove) {
  if (!fs.existsSync(filePath)) return filePath;
  let content = fs.readFileSync(filePath, 'utf8') || '';
  const bypassRegex = /bypass\s*=\s*\{([\s\S]*?)\}/m;
  if (!bypassRegex.test(content)) return filePath;

  const existingIds = parseBypassIdsFromContent(content);
  const newIds = existingIds.filter(x => x !== idToRemove);
  const newBlock = buildBypassBlock(roleName, newIds);
  const newContent = content.replace(bypassRegex, newBlock);

  const tmp = filePath + '.tmp';
  fs.writeFileSync(tmp, newContent, 'utf8');
  fs.renameSync(tmp, filePath);
  return filePath;
}

// Overwrite lua file from array of ids (used when mapping set or rewriting)
function writeLuaFromIds(filePath, roleName, ids) {
  ensureDir(LUA_DIR);
  const newBlock = buildBypassBlock(roleName, ids);
  const tmp = filePath + '.tmp';
  fs.writeFileSync(tmp, newBlock + '\n', 'utf8');
  fs.renameSync(tmp, filePath);
  return filePath;
}

// --- Slash command registration ---
async function registerCommands() {
  const add = new SlashCommandBuilder()
    .setName('addrole')
    .setDescription('Bir kullanıcıyı yerel rol dosyasına ekler (Admin gerekli).')
    .addUserOption(o => o.setName('user').setDescription('Kullanıcı').setRequired(true))
    .addStringOption(o => o.setName('rol').setDescription('Rol adı').setRequired(true))
    .addStringOption(o => o.setName('file').setDescription('(opsiyonel) hedef lua dosya adı (uzantısız)'));

  const remove = new SlashCommandBuilder()
    .setName('removerole')
    .setDescription('Bir kullanıcıyı yerel rolden kaldırır (Admin gerekli).')
    .addUserOption(o => o.setName('user').setDescription('Kullanıcı').setRequired(true))
    .addStringOption(o => o.setName('rol').setDescription('Rol adı').setRequired(true))
    .addStringOption(o => o.setName('file').setDescription('(opsiyonel) hedef lua dosya adı (uzantısız)'));

  const list = new SlashCommandBuilder()
    .setName('listrole')
    .setDescription('Bir rolün kayıtlı kullanıcılarını listeler.')
    .addStringOption(o => o.setName('rol').setDescription('Rol adı').setRequired(true))
    .addStringOption(o => o.setName('file').setDescription('(opsiyonel) hedef lua dosya adı (uzantısız)'));

  const map = new SlashCommandBuilder()
    .setName('maprole')
    .setDescription('Bir rol adını belirli bir lua dosyasına eşle (Admin gerekli).')
    .addStringOption(o => o.setName('rol').setDescription('Rol adı').setRequired(true))
    .addStringOption(o => o.setName('file').setDescription('Hedef lua dosya adı (uzantısız)').setRequired(true));

  const rest = new REST({ version: '10' }).setToken(TOKEN);
  const body = [add.toJSON(), remove.toJSON(), list.toJSON(), map.toJSON()];

  try {
    const app = await client.application.fetch();
    if (GUILD_ID) {
      await rest.put(Routes.applicationGuildCommands(app.id, GUILD_ID), { body });
      console.log('Komutlar guild düzeyinde kaydedildi.');
    } else {
      await rest.put(Routes.applicationCommands(app.id), { body });
      console.log('Komutlar global olarak kaydedildi (yayılma süresi olabilir).');
    }
  } catch (err) {
    console.error('Komut kaydederken hata:', err);
  }
}

// --- Events ---
client.once('ready', async () => {
  console.log(`Bot hazır: ${client.user.tag}`);
  await registerCommands();
});

client.on('interactionCreate', async interaction => {
  if (!interaction.isChatInputCommand()) return;
  const name = interaction.commandName;
  const member = interaction.member;

  // Admin only
  if (!member || !member.permissions.has(PermissionsBitField.Flags.Administrator)) {
    await interaction.reply({ content: 'Bu komutu çalıştırmak için Administrator yetkisine sahip olmalısın.', ephemeral: true });
    return;
  }

  if (name === 'maprole') {
    const roleName = interaction.options.getString('rol', true).trim();
    const file = interaction.options.getString('file', true).trim();
    const safe = safeLuaFilename(file);
    const mappings = loadMappings();
    mappings[roleName] = safe;
    saveMappings(mappings);

    // regenerate target lua from roles.json if any
    const roles = loadRoles();
    const ids = roles[roleName] || [];
    const filePath = getLuaPathForRole(roleName);
    writeLuaFromIds(filePath, roleName, ids);

    appendLog(`${interaction.user.tag} mapped role "${roleName}" -> ${safe}.lua`);
    await interaction.reply({ content: `Rol "${roleName}" artık ${safe}.lua dosyasına karşılık geliyor. Lua dosyası güncellendi.`, ephemeral: true });
    return;
  }

  if (name === 'addrole') {
    const target = interaction.options.getUser('user', true);
    const roleName = interaction.options.getString('rol', true).trim();
    const explicitFile = interaction.options.getString('file', false);
    const roles = loadRoles();
    if (!roles[roleName]) roles[roleName] = [];
    if (!roles[roleName].includes(target.id)) {
      roles[roleName].push(target.id);
      saveRoles(roles);

      const luaPath = getLuaPathForRole(roleName, explicitFile ? explicitFile.trim() : null);
      addIdToLuaFile(luaPath, roleName, target.id);

      appendLog(`${interaction.user.tag} added ${target.id} to ${roleName} (file: ${path.basename(luaPath)})`);
      await interaction.reply({ content: `Kullanıcı ${target.tag} (${target.id}) "${roleName}" listesine eklendi. Lua dosyası: ${path.basename(luaPath)}`, ephemeral: true });
    } else {
      await interaction.reply({ content: `Kullanıcı zaten "${roleName}" listesinde.`, ephemeral: true });
    }
    return;
  }

  if (name === 'removerole') {
    const target = interaction.options.getUser('user', true);
    const roleName = interaction.options.getString('rol', true).trim();
    const explicitFile = interaction.options.getString('file', false);
    const roles = loadRoles();
    if (!roles[roleName] || !roles[roleName].includes(target.id)) {
      await interaction.reply({ content: `Kullanıcı "${roleName}" listesinde değil.`, ephemeral: true });
      return;
    }
    roles[roleName] = roles[roleName].filter(id => id !== target.id);
    saveRoles(roles);

    const luaPath = getLuaPathForRole(roleName, explicitFile ? explicitFile.trim() : null);
    removeIdFromLuaFile(luaPath, roleName, target.id);

    appendLog(`${interaction.user.tag} removed ${target.id} from ${roleName} (file: ${path.basename(luaPath)})`);
    await interaction.reply({ content: `Kullanıcı ${target.tag} (${target.id}) "${roleName}" listesinden çıkarıldı. Lua dosyası: ${path.basename(luaPath)}`, ephemeral: true });
    return;
  }

  if (name === 'listrole') {
    const roleName = interaction.options.getString('rol', true).trim();
    const explicitFile = interaction.options.getString('file', false);
    const roles = loadRoles();
    const arr = roles[roleName] || [];
    const luaPath = getLuaPathForRole(roleName, explicitFile ? explicitFile.trim() : null);
    if (arr.length === 0) {
      await interaction.reply({ content: `"${roleName}" için kayıtlı kullanıcı yok. (Lua dosyası: ${path.basename(luaPath)})`, ephemeral: true });
      return;
    }
    const shown = arr.slice(0, 50).map(id => `- ${id}`).join('\n');
    const more = arr.length > 50 ? `\n... ve ${arr.length - 50} daha` : '';
    await interaction.reply({ content: `"${roleName}" (${arr.length}) kullanıcılar (Lua dosyası: ${path.basename(luaPath)}):\n${shown}${more}`, ephemeral: true });
    return;
  }
});

client.login(TOKEN);
